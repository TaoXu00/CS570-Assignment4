/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */
//token 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
#include <stdio.h> // For printf, etc.
#include <rpc/rpc.h> // For RPC facilities.
#include <string.h> // For strcpy, strcmp, strdup, strlen, etc.
#include "ssnfs.h" // Automatically generated rpc service header.
#include <unistd.h> // Needed for access, etc.
#include <fcntl.h> // Needed for ftruncate, etc.
#include <errno.h> // Need for errno, strerror, etc


#define MAX_FILES 20 // The maximum number of files in the filesystem.
#define MAX_PAGES 8 // The maximum number of pages per file.
#define BLOCK_SIZE 512 // Blocks are 512 bytes.
#define PAGE_SIZE (BLOCK_SIZE*8) // Pages are 8 blocks.
#define FILE_BLOCK 64
#define TEN_M 1024*1024*16 

struct file_info { // Holds the file information.
    char username[10]; // Username of the file's owner.
    char filename[10]; // Name of the file.
    int fd; // file descriptor.  
	int startblock;
    int r_offset;
    int w_offset;
}; // End of struct file_info.

struct f_node{
char username[10];
char filename[10];
int  startblock;
int  offset;
};
typedef struct file_info file_info;    //Define as a type 
typedef struct f_node  f_node;


int init_disk() {
    if ((access("files.dat", F_OK) == 0) && (access("pages.dat", F_OK) == 0) && (access("disk.dat", F_OK) == 0)) {
    } else { //ftruncate is to creat a file with specific size
        ftruncate(creat("disk.dat", 0666), 1024*1024*16); //store the files 
        ftruncate(creat("pages.dat", 0666), 2560);
        ftruncate(creat("files.dat", 0666), sizeof(file_info) * MAX_FILES); //keep the information of file_info
    }
}

// Checks if a file exists.  Return -1 on false, file disciptor on true.
int file_exists(char *username, char *filename) {
    int fd, exists;
    int fd_file=-1;  //file does not exit
    file_info fi;
    fd = open("files.dat", O_RDONLY);
    for (exists = 0; read(fd, &fi, sizeof(fi)) > 0;) {
        if ((strcmp(username, fi.username) == 0) && (strcmp(filename, fi.filename) == 0)) {
            exists = 1;
            fd_file=fi.fd;
            break;
        }
    }
    close(fd);
    return fd_file;
}

// Get information on a file.  Takes the username, filename, and a pointer to a file_info struct.
// Not correct, to be modified
void get_file_info(char *username, char *filename, file_info *fi) {
    int fd, exists;
    fd = open("files.dat", O_RDONLY);
    for (exists = 0; read(fd, fi, sizeof(file_info)) > 0;) {
        if ((strcmp(username, fi->username) == 0) && (strcmp(filename, fi->filename) == 0)) {
            exists = 1;
            break;
        }
    }
    close(fd);
}

// Commit changes to a file_info struct.  Takes only a file_info struct pointer as input.
/*void change_file_info(file_info *fi) {
    int fd, exists;
    file_info block;
    fd = open("files.dat", O_RDWR);
    for (exists = 0; read(fd, &block, sizeof(file_info)) > 0;) {
        if ((strcmp(fi->username, block.username) == 0) && (strcmp(fi->filename, block.filename) == 0)) {
            exists = 1;
            break;
        }
    }
    if (exists) {
        lseek(fd, -sizeof(file_info), SEEK_CUR);
        printf("used %d\n", fi->used);
        printf("write %zd\n", write(fd, fi, sizeof(file_info)));
    }
    close(fd);
}*/

// Inserts a new file_info struct into the file table, return the file discriptor
int add_file(file_info fi) {
    int fd;
    int found;
    file_info block;
    // search for an empty block
    fd = open("files.dat", O_RDWR);
    for (found = 0; read(fd, &block, sizeof(block)) > 0;) {
        if (block.username[0] == 0) {
            found=1;
            break;
        }    
    }
    // insert file
    if (found) {
        lseek(fd, -sizeof(fi), SEEK_CUR);
        printf("write %zd\n", write(fd, &fi, sizeof(fi)));
    }else
    found=-1;
    close(fd);
    // return success
    return found;
}

int assign_fd(){
    int found, fd, last_fd=-1;
    file_info block;
    // search for an empty block
    fd = open("files.dat", O_RDWR);
    for (; read(fd, &block, sizeof(block)) > 0;) {
	printf("in the assign_fd loop");
        if (block.username[0] == 0) {    
            last_fd++;   //the first file has the fd=0, the last_fd will be incresed by 1 for the new file
            //printf("found an empty block %d\n", last_fd);   //debug
	    break;
        }else{
        last_fd=block.fd; // record the fd of the previous file
	//printf("found one block not empty, %s:%s:%d\n", block.username, block.filename,block.fd);	//debug
	}    
}
    // insert file 
    close(fd);
    // return success
    return last_fd; 
}
int allocate_block(int fd_file){
    //return the start block number, -1 for exceed the maximum space
    int startblock=fd_file*FILE_BLOCK;
    if((startblock+FILE_BLOCK)*BLOCK_SIZE>TEN_M)
    startblock=-1;
    return startblock; 
}
open_output *
open_file_1_svc(open_input *argp, struct svc_req *rqstp)
{
	static open_output  result;
    int fd,fd_file;
	int startblock;
    file_info fi;
    char message[512];
    printf("open_file_1_svc: (user_name = '%s', file_name = '%s')\n", argp->user_name, argp->file_name);
    init_disk();
    fd_file=file_exists(argp->user_name, argp->file_name);
    //printf("fd_file:%d\n",fd_file);    //debug
    if (fd_file==-1) {   //if the file not exists
        fd_file=assign_fd(); 
 	//printf("Assinged file id: %d\n", fd_file);  //debug
        if(fd_file==MAX_FILES){  //fd_file starts from 0, if fd_file =20, it exceeds the maximum file number
            snprintf(message, 512, "In server: Error: Max number of files reseached");
        }else{
            startblock = allocate_block(fd_file);
                if (startblock!= -1){   //both the file number and the space are fine
                    strcpy(fi.username,argp->user_name);
                    strcpy(fi.filename,argp->file_name);
                    fi.fd=fd_file;
                    fi.startblock = startblock;
		    fi.offset=0;
                    if (add_file(fi))//file add succussfully
                        snprintf(message, 512, "In server: %s created for user %s, allocate %d blocks starting from %d", argp->file_name, argp->user_name, FILE_BLOCK, startblock);
                    else 
                        snprintf(message, 512, "In server: Error happened.");
                }
                else
                    snprintf(message, 512, "%s", "In server: No space for creating a new file");
            }
    }   
    else //file already exist
        snprintf(message, 512, "In server: File Found with file discriptor %d", fd_file);
    
    printf("%s\n", message);
    result.fd=fd_file;
    result.out_msg.out_msg_len = strlen(message) + 1;
    free(result.out_msg.out_msg_val);
    result.out_msg.out_msg_val=(char *) malloc(result.out_msg.out_msg_len);
    strcpy(result.out_msg.out_msg_val, (*argp).file_name);
    printf("In server: filename recieved:%s\n",argp->file_name);
	printf("In server: username received:%s\n",argp->user_name);
	return &result;
}

read_output *
read_file_1_svc(read_input *argp, struct svc_req *rqstp)
{
	static read_output  result;



	return &result;
}

write_output *
write_file_1_svc(write_input *argp, struct svc_req *rqstp)
{
	static write_output  result;

	

	return &result;
}

list_output *
list_files_1_svc(list_input *argp, struct svc_req *rqstp)
{
	static list_output  result;
	


	return &result;
}

delete_output *
delete_file_1_svc(delete_input *argp, struct svc_req *rqstp)
{
	static delete_output  result;



	return &result;
}

close_output *
close_file_1_svc(close_input *argp, struct svc_req *rqstp)
{
	static close_output  result;



	return &result;
}



